diff --git a/core/array_constraints.cpp b/core/array_constraints.cpp
index 68c5d70..54e942d 100644
--- a/core/array_constraints.cpp
+++ b/core/array_constraints.cpp
@@ -264,23 +264,6 @@ void allDiffArcCons(NsIntVarArray* VarArr,
 void Ns_ConstrAllDiff::ArcCons(void)
 {
         NsIntVarArray::iterator X, Y;
-        // Dovecote Theorem (to spot a dead-end earlier) //
-        NsInt min_of_arr, max_of_arr;
-        X = VarArr->begin();
-        min_of_arr = X->min();
-        max_of_arr = X->max();
-        ++X;
-        for (; X != VarArr->end(); ++X) {
-                if (X->min() < min_of_arr)
-                        min_of_arr = X->min();
-                if (X->max() > max_of_arr)
-                        max_of_arr = X->max();
-        }
-        if (static_cast<NsUInt>(max_of_arr - min_of_arr) + 1 < VarArr->size()) {
-                // all values are inconsistent
-                VarArr->begin()->removeAll();
-                return;
-        }
         // Classic ArcCons //
         NsQueue<const NsIntVar*> newBoundVars;
         for (X = VarArr->begin(); X != VarArr->end(); ++X) {
@@ -650,7 +633,10 @@ Ns_ConstrTable::Ns_ConstrTable(NsIntVarArray& VarArr_init,
     table(table_init),
     isSupportsTable(isSupportsTable_init)
 {
-        revisionType = BIDIRECTIONAL_CONSISTENCY;
+        if (isSupportsTable)
+                revisionType = BIDIRECTIONAL_ARC_CONSISTENCY;
+        else
+                revisionType = BIDIRECTIONAL_CONSISTENCY;
         assert_Ns(VarArr.size() >= 2,
                   "A table constraint must refer at least to two variables");
         for (NsDeque<NsDeque<NsInt>>::const_iterator tuple = table.begin();
@@ -672,14 +658,8 @@ Ns_ConstrTable::Ns_ConstrTable(NsIntVarArray& VarArr_init,
 
 void Ns_ConstrTable::ArcConsSupports(void)
 {
-        // Initialize the supported variables' bounds
-        NsDeque<NsInt> VarArrMin(VarArr.size());
-        NsDeque<NsInt> VarArrMax(VarArr.size());
         NsDeque<NsInt>::size_type i;
-        for (i = 0; i < VarArr.size(); ++i) {
-                VarArrMin[i] = NsPLUS_INF;
-                VarArrMax[i] = NsMINUS_INF;
-        }
+        NsDeque<set<NsInt>> VarArrSupportValues(VarArr.size());
         // Iterate through the tuples of supporting values
         for (NsDeque<NsDeque<NsInt>>::const_iterator tuple = table.begin();
              tuple != table.end(); ++tuple) {
@@ -689,18 +669,14 @@ void Ns_ConstrTable::ArcConsSupports(void)
                                 break; // tuple is not supporting
                 if (i == tuple->size()) {
                         // This is a support tuple!
-                        // Update the (supported) bounds for each variable
-                        for (i = 0; i < tuple->size(); ++i) {
-                                update_min_max((*tuple)[i], VarArrMin[i],
-                                               VarArrMax[i]);
-                        }
+                        for (i = 0; i < tuple->size(); ++i)
+                                VarArrSupportValues[i].insert((*tuple)[i]);
                 }
         }
-        // Update the supported variables' bounds
-        for (i = 0; i < VarArr.size(); ++i) {
-                VarArr[i].removeRange(NsMINUS_INF, VarArrMin[i] - 1, this);
-                VarArr[i].removeRange(VarArrMax[i] + 1, NsPLUS_INF, this);
-        }
+        // Update the supported variables' values
+        bool foo;
+        for (i = 0; i < VarArr.size(); ++i)
+                set_to_domain(VarArrSupportValues[i], VarArr[i], this, foo);
 }
 
 void Ns_ConstrTable::ArcConsConflicts(void)
diff --git a/core/internal.h b/core/internal.h
index 9b85f73..c10de23 100644
--- a/core/internal.h
+++ b/core/internal.h
@@ -8,6 +8,7 @@
 #define Ns_INTERNAL_H
 
 #include "naxos-mini.h"
+#include <set>
 
 bool intersectionEmpty(const naxos::NsIntVar* VarY,
                        const naxos::NsIntVar* VarZ);
@@ -44,4 +45,7 @@ void array_VarArr_elements_min_max(const naxos::NsIntVarArray& VarArr,
 void update_min_max(const naxos::NsInt candidate, naxos::NsInt& min,
                     naxos::NsInt& max);
 
+void set_to_domain(std::set<naxos::NsInt>& S, naxos::NsIntVar& V,
+                   const naxos::Ns_Constraint* constraint, bool& modification);
+
 #endif // Ns_INTERNAL_H
diff --git a/core/naxos-mini.h b/core/naxos-mini.h
index 32d8baa..4b1812b 100644
--- a/core/naxos-mini.h
+++ b/core/naxos-mini.h
@@ -1430,7 +1430,7 @@ class Ns_ConstrXeqYtimesC : public Ns_Constraint {
         Ns_ConstrXeqYtimesC(NsIntVar* X, NsIntVar* Y, const NsInt C_init)
           : VarX(X), VarY(Y), C(C_init)
         {
-                revisionType = BIDIRECTIONAL_CONSISTENCY;
+                revisionType = VALUE_CONSISTENCY;
                 assert_Ns(&VarX->manager() == &VarY->manager(),
                           "Ns_ConstrXeqYtimesC::Ns_ConstrXeqYtimesC: All the "
                           "variables of a constraint must belong to the same "
@@ -2210,7 +2210,7 @@ class Ns_ConstrXeqY : public Ns_Constraint {
     public:
         Ns_ConstrXeqY(NsIntVar* X, NsIntVar* Y) : VarX(X), VarY(Y)
         {
-                revisionType = BIDIRECTIONAL_CONSISTENCY;
+                revisionType = VALUE_CONSISTENCY;
                 assert_Ns(&VarX->manager() == &VarY->manager(),
                           "Ns_ConstrXeqY::Ns_ConstrXeqY: All the variables of "
                           "a constraint must belong to the same "
diff --git a/core/var_constraints.cpp b/core/var_constraints.cpp
index 076ad53..c1b9867 100644
--- a/core/var_constraints.cpp
+++ b/core/var_constraints.cpp
@@ -528,55 +528,58 @@ void Ns_ConstrXeqCminusY::LocalArcCons(Ns_QueueItem& /*Qitem*/)
 
 void Ns_ConstrXeqYtimesC::ArcCons(void)
 {
-        bool modification;
-        do {
-                modification = false;
-                if (C >= 0) {
-                        VarX->removeRange(NsMINUS_INF, VarY->min() * C - 1,
-                                          this, modification);
-                        VarX->removeRange(VarY->max() * C + 1, NsPLUS_INF, this,
-                                          modification);
-                        VarY->removeRange(NsMINUS_INF, VarX->min() / C - 1,
-                                          this, modification);
-                        VarY->removeRange(VarX->max() / C + 1, NsPLUS_INF, this,
-                                          modification);
-                } else {
-                        VarX->removeRange(NsMINUS_INF, VarY->max() * C - 1,
-                                          this, modification);
-                        VarX->removeRange(VarY->min() * C + 1, NsPLUS_INF, this,
-                                          modification);
-                        VarY->removeRange(NsMINUS_INF, VarX->max() / C - 1,
-                                          this, modification);
-                        VarY->removeRange(VarX->min() / C + 1, NsPLUS_INF, this,
-                                          modification);
-                }
-        } while (modification);
+        NsIntVar::const_iterator v;
+        for (v = VarX->begin(); v != VarX->end(); ++v) {
+                if (*v % C != 0 || !VarY->contains(*v / C))
+                        VarX->removeSingle(*v, this);
+        }
+        for (v = VarY->begin(); v != VarY->end(); ++v) {
+                if (!VarX->contains(*v * C))
+                        VarY->removeSingle(*v, this);
+        }
 }
 
-void Ns_ConstrXeqYtimesC::LocalArcCons(Ns_QueueItem& /*Qitem*/)
+void Ns_ConstrXeqYtimesC::LocalArcCons(Ns_QueueItem& Qitem)
 {
-        ArcCons();
+        NsInt SupportVal;
+        if (VarX == Qitem.getVarFired()) {
+                SupportVal = Qitem.getW() / C;
+                if (Qitem.getW() % C == 0 && VarY->contains(SupportVal))
+                        VarY->removeSingle(SupportVal, this);
+        } else {
+                assert_Ns(
+                    VarY == Qitem.getVarFired(),
+                    "Ns_ConstrXeqYtimesC::LocalArcCons: Wrong getVarFired");
+                SupportVal = Qitem.getW() * C;
+                if (VarX->contains(SupportVal))
+                        VarX->removeSingle(SupportVal, this);
+        }
 }
 
 void Ns_ConstrXeqY::ArcCons(void)
 {
-        bool modification;
-        do {
-                modification = false;
-                VarX->removeRange(NsMINUS_INF, VarY->min() - 1, this,
-                                  modification);
-                VarX->removeRange(VarY->max() + 1, NsPLUS_INF, this,
-                                  modification);
-                VarY->removeRange(NsMINUS_INF, VarX->min() - 1, this,
-                                  modification);
-                VarY->removeRange(VarX->max() + 1, NsPLUS_INF, this,
-                                  modification);
-        } while (modification);
+        NsIntVar::const_iterator v;
+        for (v = VarX->begin(); v != VarX->end(); ++v) {
+                if (!VarY->contains(*v))
+                        VarX->removeSingle(*v, this);
+        }
+        for (v = VarY->begin(); v != VarY->end(); ++v) {
+                if (!VarX->contains(*v))
+                        VarY->removeSingle(*v, this);
+        }
 }
 
-void Ns_ConstrXeqY::LocalArcCons(Ns_QueueItem& /*Qitem*/)
+void Ns_ConstrXeqY::LocalArcCons(Ns_QueueItem& Qitem)
 {
-        ArcCons();
+        if (VarX == Qitem.getVarFired()) {
+                if (VarY->contains(Qitem.getW()))
+                        VarY->removeSingle(Qitem.getW(), this);
+        } else {
+                assert_Ns(VarY == Qitem.getVarFired(),
+                          "Ns_ConstrXeqY::LocalArcCons: Wrong getVarFired");
+                if (VarX->contains(Qitem.getW()))
+                        VarX->removeSingle(Qitem.getW(), this);
+        }
 }
 
 void Ns_ConstrXeqYdivC::ArcCons(void)
@@ -1046,6 +1049,20 @@ void Ns_ConstrXorY::LocalArcCons(Ns_QueueItem& Qitem)
         }
 }
 
+/// Projects the set of values S to the domain of V
+void set_to_domain(set<NsInt>& S, NsIntVar& V, const Ns_Constraint* constraint,
+                   bool& modification)
+{
+        NsInt previous_val = NsMINUS_INF;
+        for (set<NsInt>::const_iterator val = S.begin(); val != S.end();
+             ++val) {
+                V.removeRange(previous_val + 1, *val - 1, constraint,
+                              modification);
+                previous_val = *val;
+        }
+        V.removeRange(previous_val + 1, NsPLUS_INF, constraint, modification);
+}
+
 // bounds-consistency only
 void Ns_ConstrXeqYplusZ::ArcCons(void)
 {

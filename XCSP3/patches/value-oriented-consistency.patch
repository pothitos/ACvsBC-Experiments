diff --git a/core/array_constraints.cpp b/core/array_constraints.cpp
index aa8386c..53b1f97 100644
--- a/core/array_constraints.cpp
+++ b/core/array_constraints.cpp
@@ -7,6 +7,7 @@
 #include "naxos-mini.h"
 #include <algorithm>
 #include <cstdlib>
+#include <set>
 
 using namespace naxos;
 using namespace std;
@@ -672,14 +673,8 @@ Ns_ConstrTable::Ns_ConstrTable(NsIntVarArray& VarArr_init,
 
 void Ns_ConstrTable::ArcConsSupports(void)
 {
-        // Initialize the supported variables' bounds
-        NsDeque<NsInt> VarArrMin(VarArr.size());
-        NsDeque<NsInt> VarArrMax(VarArr.size());
         NsDeque<NsInt>::size_type i;
-        for (i = 0; i < VarArr.size(); ++i) {
-                VarArrMin[i] = NsPLUS_INF;
-                VarArrMax[i] = NsMINUS_INF;
-        }
+        NsDeque<set<NsInt>> VarArrSupportValues(VarArr.size());
         // Iterate through the tuples of supporting values
         for (NsDeque<NsDeque<NsInt>>::const_iterator tuple = table.begin();
              tuple != table.end(); ++tuple) {
@@ -689,17 +684,20 @@ void Ns_ConstrTable::ArcConsSupports(void)
                                 break; // tuple is not supporting
                 if (i == tuple->size()) {
                         // This is a support tuple!
-                        // Update the (supported) bounds for each variable
-                        for (i = 0; i < tuple->size(); ++i) {
-                                update_min_max((*tuple)[i], VarArrMin[i],
-                                               VarArrMax[i]);
-                        }
+                        for (i = 0; i < tuple->size(); ++i)
+                                VarArrSupportValues[i].insert((*tuple)[i]);
                 }
         }
-        // Update the supported variables' bounds
+        // Update the supported variables' values
         for (i = 0; i < VarArr.size(); ++i) {
-                VarArr[i].removeRange(NsMINUS_INF, VarArrMin[i] - 1, this);
-                VarArr[i].removeRange(VarArrMax[i] + 1, NsPLUS_INF, this);
+                NsInt value = NsMINUS_INF;
+                for (set<NsInt>::const_iterator val =
+                         VarArrSupportValues[i].begin();
+                     val != VarArrSupportValues[i].end(); ++val) {
+                        value = *val;
+                        VarArr[i].removeRange(NsMINUS_INF, value - 1, this);
+                }
+                VarArr[i].removeRange(value + 1, NsPLUS_INF, this);
         }
 }
 
diff --git a/core/naxos-mini.h b/core/naxos-mini.h
index 7635e12..8d02005 100644
--- a/core/naxos-mini.h
+++ b/core/naxos-mini.h
@@ -1422,7 +1422,7 @@ class Ns_ConstrXeqYtimesC : public Ns_Constraint {
         Ns_ConstrXeqYtimesC(NsIntVar* X, NsIntVar* Y, const NsInt C_init)
           : VarX(X), VarY(Y), C(C_init)
         {
-                revisionType = BIDIRECTIONAL_CONSISTENCY;
+                revisionType = VALUE_CONSISTENCY;
                 assert_Ns(&VarX->manager() == &VarY->manager(),
                           "Ns_ConstrXeqYtimesC::Ns_ConstrXeqYtimesC: All the "
                           "variables of a constraint must belong to the same "
diff --git a/core/var_constraints.cpp b/core/var_constraints.cpp
index 076ad53..9edcb33 100644
--- a/core/var_constraints.cpp
+++ b/core/var_constraints.cpp
@@ -528,34 +528,32 @@ void Ns_ConstrXeqCminusY::LocalArcCons(Ns_QueueItem& /*Qitem*/)
 
 void Ns_ConstrXeqYtimesC::ArcCons(void)
 {
-        bool modification;
-        do {
-                modification = false;
-                if (C >= 0) {
-                        VarX->removeRange(NsMINUS_INF, VarY->min() * C - 1,
-                                          this, modification);
-                        VarX->removeRange(VarY->max() * C + 1, NsPLUS_INF, this,
-                                          modification);
-                        VarY->removeRange(NsMINUS_INF, VarX->min() / C - 1,
-                                          this, modification);
-                        VarY->removeRange(VarX->max() / C + 1, NsPLUS_INF, this,
-                                          modification);
-                } else {
-                        VarX->removeRange(NsMINUS_INF, VarY->max() * C - 1,
-                                          this, modification);
-                        VarX->removeRange(VarY->min() * C + 1, NsPLUS_INF, this,
-                                          modification);
-                        VarY->removeRange(NsMINUS_INF, VarX->max() / C - 1,
-                                          this, modification);
-                        VarY->removeRange(VarX->min() / C + 1, NsPLUS_INF, this,
-                                          modification);
-                }
-        } while (modification);
+        NsIntVar::const_iterator v;
+        for (v = VarX->begin(); v != VarX->end(); ++v) {
+                if (*v % C != 0 || !VarY->contains(*v / C))
+                        VarX->removeSingle(*v, this);
+        }
+        for (v = VarY->begin(); v != VarY->end(); ++v) {
+                if (!VarX->contains(*v * C))
+                        VarY->removeSingle(*v, this);
+        }
 }
 
-void Ns_ConstrXeqYtimesC::LocalArcCons(Ns_QueueItem& /*Qitem*/)
+void Ns_ConstrXeqYtimesC::LocalArcCons(Ns_QueueItem& Qitem)
 {
-        ArcCons();
+        NsInt SupportVal;
+        if (VarX == Qitem.getVarFired()) {
+                SupportVal = Qitem.getW() / C;
+                if (Qitem.getW() % C == 0 && VarY->contains(SupportVal))
+                        VarY->removeSingle(SupportVal, this);
+        } else {
+                assert_Ns(
+                    VarY == Qitem.getVarFired(),
+                    "Ns_ConstrXeqYtimesC::LocalArcCons: Wrong getVarFired");
+                SupportVal = Qitem.getW() * C;
+                if (VarX->contains(SupportVal))
+                        VarX->removeSingle(SupportVal, this);
+        }
 }
 
 void Ns_ConstrXeqY::ArcCons(void)
